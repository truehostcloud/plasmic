// This is a skeleton starter React component generated by Plasmic.
// This file is owned by you, feel free to edit as you see fit.
import {
  useAppAccessRegistries,
  useAppAccessRules,
  useAppRoles,
  useMutateHostAppAuthData,
} from "@/wab/client/components/app-auth/app-auth-contexts";
import { maybeShowContextMenu } from "@/wab/client/components/ContextMenu";
import { confirm } from "@/wab/client/components/quick-modals";
import { Icon } from "@/wab/client/components/widgets/Icon";
import IconButton from "@/wab/client/components/widgets/IconButton";
import Select from "@/wab/client/components/widgets/Select";
import Textbox from "@/wab/client/components/widgets/Textbox";
import { useAppCtx } from "@/wab/client/contexts/AppContexts";
import { useTopFrameCtx } from "@/wab/client/frame-ctx/top-frame-ctx";
import {
  DefaultActivityTabProps,
  PlasmicActivityTab,
} from "@/wab/client/plasmic/plasmic_kit_end_user_management/PlasmicActivityTab";
import Refresh2SvgIcon from "@/wab/client/plasmic/plasmic_kit_icons/icons/PlasmicIcon__Refresh2Svg";
import { ApiAppAccessRegistry, ApiAppRole } from "@/wab/shared/ApiSchema";
import { withoutNils } from "@/wab/shared/common";
import { HTMLElementRefOf } from "@plasmicapp/react-web";
import { Menu, Table, Tooltip } from "antd";
import moment from "moment";
import * as React from "react";

export interface ActivityTabProps extends DefaultActivityTabProps {
  projectId: string;
}

function getHighestRole(roles: ApiAppRole[]) {
  if (roles.length === 0) {
    return undefined;
  }

  const role = roles.reduce((prev, cur) => {
    if (cur.order > prev.order) {
      return cur;
    }
    return prev;
  });
  return role;
}

const PAGE_SIZE = 10;

function ActivityTab_(props: ActivityTabProps, ref: HTMLElementRefOf<"div">) {
  const appCtx = useAppCtx();
  const { projectId, ...rest } = props;
  const [pageIndex, setPageIndex] = React.useState(0);
  const [search, setSearch] = React.useState("");
  const { roles, loading: isRolesLoading } = useAppRoles(appCtx, projectId);
  const { mutate: mutateAccessesRules } = useAppAccessRules(appCtx, projectId);
  const { hostFrameApi } = useTopFrameCtx();

  const {
    accesses,
    total,
    loading: isAccessesLoading,
    mutate: refreshAccesses,
  } = useAppAccessRegistries(appCtx, projectId, {
    pageSize: PAGE_SIZE,
    pageIndex,
    search,
  });

  const mutateHostAppAuthData = useMutateHostAppAuthData(projectId);

  async function mutateDependencies() {
    await mutateAccessesRules();
    await mutateHostAppAuthData();

    await refreshAccesses();
  }

  return (
    <PlasmicActivityTab
      root={{ ref }}
      children={
        <>
          <div className="flex fill-width flex-push-right">
            <Textbox
              styleType="bordered"
              className="fill-width"
              placeholder="Search by email"
              value={search}
              onChange={(e) => {
                setSearch(e.target.value);
              }}
            />
            <Tooltip title={"Refresh table data"}>
              <IconButton
                className="ml-sm"
                onClick={async () => {
                  await refreshAccesses();
                }}
              >
                <Icon icon={Refresh2SvgIcon} />
              </IconButton>
            </Tooltip>
          </div>
          <Table
            className="mt-sm"
            style={{
              width: "100%",
            }}
            pagination={{
              total,
              pageSize: PAGE_SIZE,
              current: pageIndex + 1,
            }}
            loading={isAccessesLoading || isRolesLoading}
            dataSource={accesses}
            onRow={(record) => {
              const role = getHighestRole(
                record.matchedRoles.map((r) => r.role)
              );
              const canRevokePermission =
                record.matchedRoles.filter(
                  (r) => r.reason === "email" || r.reason === "external-id"
                ).length > 0 || record.matchedRoles.length === 0;
              return {
                onContextMenu: (e) => {
                  maybeShowContextMenu(
                    e as any,
                    <Menu>
                      <Menu.Item
                        disabled={!role?.id}
                        onClick={async () => {
                          await hostFrameApi.logAsAppUser({
                            isLoggedIn: true,
                            email: record.endUserEmail,
                            externalId: record.endUserExternalId,
                            // custom props should be later filled by the host frame
                            customProperties: {},
                            properties: {},
                            roleId: role?.id!,
                            roleName: role?.name!,
                            roleIds: roles
                              .filter((r) => r.order <= (role?.order ?? 0))
                              .map((r) => r.id),
                          });
                        }}
                      >
                        View as this user
                      </Menu.Item>
                      <Menu.Item
                        disabled={!canRevokePermission}
                        onClick={async () => {
                          const isUserLosingAccess = !record.matchedRoles.some(
                            (r) =>
                              r.reason !== "email" && r.reason !== "external-id"
                          );

                          const newRole = getHighestRole(
                            record.matchedRoles
                              .filter(
                                (r) =>
                                  r.reason !== "email" &&
                                  r.reason !== "external-id"
                              )
                              .map((r) => r.role)
                          );

                          const hardConfirm = await confirm({
                            title: `Are you sure?`,
                            message: `This is going to remove the access log of this user. ${
                              isUserLosingAccess
                                ? "This user will lose access to this app."
                                : `This user will still have access to this app through other rules from the permission list, but their new role will be "${newRole?.name}".`
                            }`,
                          });

                          if (hardConfirm) {
                            const accessId = record.matchedRoles.find(
                              (r) =>
                                r.reason === "email" ||
                                r.reason === "external-id"
                            )?.accessId;

                            if (accessId) {
                              await appCtx.api.deleteAccessRule(
                                projectId,
                                accessId
                              );

                              await appCtx.api.deleteAppAccessRegister(
                                projectId,
                                record.id
                              );

                              await mutateDependencies();
                            }
                          }
                        }}
                      >
                        <Tooltip
                          title={
                            canRevokePermission
                              ? "Revoke user access to the app."
                              : `This user is allowed to the app through domain, groups or general access, remove those rules to be able to revoke the access`
                          }
                        >
                          {record.matchedRoles.length === 0
                            ? "Remove from list"
                            : "Revoke access"}
                        </Tooltip>
                      </Menu.Item>
                    </Menu>
                  );
                },
              };
            }}
            rowKey="id"
            columns={[
              {
                title: "Identifier",
                dataIndex: "",
                render(_, record: ApiAppAccessRegistry) {
                  return (
                    <>
                      {record.endUserEmail ? (
                        <>
                          <div> Email: </div>
                          <div> {record.endUserEmail}</div>
                        </>
                      ) : (
                        <>
                          <div> External ID: </div>
                          <div> {record.endUserExternalId}</div>
                        </>
                      )}
                    </>
                  );
                },
              },
              {
                title: "Role",
                dataIndex: "matchedRoles",
                render: (
                  matchedRoles: ApiAppAccessRegistry["matchedRoles"],
                  record: ApiAppAccessRegistry
                ) => {
                  const role = getHighestRole(matchedRoles.map((r) => r.role));
                  const minRoleOrder =
                    getHighestRole(
                      matchedRoles
                        .filter(
                          (r) =>
                            r.reason !== "email" && r.reason !== "external-id"
                        )
                        .map((r) => r.role)
                    )?.order ?? 1;

                  return (
                    <Select
                      value={role?.id ?? "none"}
                      onChange={async (newRoleId) => {
                        if (!newRoleId) {
                          return;
                        }

                        const personalAccessId = matchedRoles.find(
                          (r) =>
                            r.reason === "email" || r.reason === "external-id"
                        )?.accessId;
                        if (personalAccessId) {
                          await appCtx.api.updateAccessRule(
                            projectId,
                            personalAccessId,
                            newRoleId
                          );
                        } else {
                          // External Id can only receive permission directly through
                          await appCtx.api.createAppAccessRules({
                            appId: projectId,
                            emails: withoutNils([record.endUserEmail]),
                            externalIds: withoutNils([
                              record.endUserExternalId,
                            ]),
                            domains: [],
                            directoryEndUserGroupIds: [],
                            roleId: newRoleId,
                            notify: false,
                          });
                        }

                        await mutateDependencies();
                      }}
                    >
                      {roles
                        ?.filter((r) => r.order >= minRoleOrder)
                        .map((r) => (
                          <Select.Option key={r.id} value={r.id}>
                            {r.name}
                          </Select.Option>
                        ))}
                      {matchedRoles.length === 0 && (
                        <Select.Option value={"none"}>No role</Select.Option>
                      )}
                    </Select>
                  );
                },
              },
              {
                title: "Last Accessed At",
                dataIndex: "updatedAt",
                render: (updatedAt: string) => {
                  return moment(updatedAt).fromNow();
                },
              },
            ]}
            onChange={(pagination) => {
              pagination.current && setPageIndex(pagination.current - 1);
            }}
          />
        </>
      }
      {...rest}
    />
  );
}

const ActivityTab = React.forwardRef(ActivityTab_);
export default ActivityTab;
